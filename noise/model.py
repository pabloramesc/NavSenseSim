import numpy as np



def extend_data(true_t, true_data, sample_rate):
    """
    Interpolate random spaced data to get uniformally sapaced data.

    Arguments
    ----------
    true_t : numpy.ndarray
        N size array with time of each sample.
    true_data : numpy.ndarray
        N-by-D array with N samples of D dimensions of original data.
    sample_rate : float
        Desired frequency to space the interpolated data.

    Returns
    -------
    _ : numpy.ndarray or float
        M-by-D array with M samples of D dimensions of interpolated data.

    """
    t_min = np.amin(true_t)
    t_max = np.amax(true_t)
    dt = 1/sample_rate
    extend_t = np.arange(t_min, t_max+dt, dt)
    return np.interp(extend_t, true_t, true_data)



def get_white_noise(noise_density, sample_period, dt, nlen=1):
    """
    Generate white noise of desired characteristics.

    formula:    WN_k = N / sqrt(dt) * wk
    where:
        WN_k is white noise in instant k
        N is noise density parameter of allan variance analysis
        dt is de sampling period (cte, variable, average or ...)
        wk is normal estandar gaussian distribued noise N(0,1) in instant k

    Arguments
    ----------
    noise_density : float
        Density of random noise paramter of the simulated sensor.
    sample_period : float
        Sampling period of the simulated sensor.
    dt : np.ndarray
        N array of the sampling periods to compute the integration.
    nlen: int, default: 1
        Number of samples of white noise to return.

    Returns
    -------
    _ : numpy.ndarray or float
        N array with nlen samples of white noise.

    """
    # noise_density_disc = noise_density / np.sqrt(sample_period) # x/sqrt(Hz) * sqrt(Hz) 
    # white_noise = noise_density_disc * np.random.normal(0,1,nlen)
    white_noise = noise_density/np.sqrt(dt) * np.random.normal(0,1,nlen)
    return white_noise



def get_pink_noise(bias_instability, correlation_time, sample_period, dt, pink_noise_prev=0.0, nlen=1):
    """
    Generate pink (flicker) noise of desired characteristics.
    It is generated by using a gauss-markov first order process.

    formula:    PN_k = (1 - beta*dt) * PN_k-1 + B * sqrt(1 - exp(-2*dt/Tc)) * wk
    where:
        PN_k is pink noise in instant k
        PN_k-1 is pink noise in the previous instant k
        B is bias instability parameter of allan variance analysis
        Tc is correlation time asociated with the bias instability
        beta is the inverse of Tc (beta = 1/Tc)
        dt is de sampling period (cte, variable, average or ...)
        wk is normal estandar gaussian distribued noise N(0,1) in instant k

    Arguments
    ----------
    bias_instability : float
        Bias instability parameter of the simulated sensor.
    correlation_time : float
        Correlation time parameter of the simulated sensor.
    sample_period : float
        Sampling period of the simulated sensor.
    dt : np.ndarray
        N array of the sampling periods to compute the integration.
    pink_noise_prev : float, default: 0.0
        Previous pink noise to start from
    nlen: int, default: 1
        Number of samples of pink noise to return.

    Returns
    -------
    _ : np.ndarray or float
        N array with nlen samples of pink noise.

    """
    # bias_instability_disc = bias_instability * np.sqrt(1.0 - np.exp(-2.0 * sample_period / correlation_time))
    
    # if nlen == 1:
    #     pink_noise = (1.0 - sample_period / correlation_time) * pink_noise_prev + bias_instability_disc * np.random.normal(0,1)
    #     return pink_noise
    
    # if nlen > 1:
    #     pink_noise = np.zeros(nlen+1)
    #     pink_noise[0] = pink_noise_prev
    #     for k in range(1,nlen+1):
    #         pink_noise[k] = (1.0 - sample_period / correlation_time) * pink_noise[k-1] + bias_instability_disc * np.random.normal(0,1)
    #     return pink_noise[1:]
    pink_noise = np.zeros(nlen)
    if nlen == 1: dt = np.array([dt])
    for k in range(nlen):
        pink_noise[k] = (1.0 - dt[k]/correlation_time)*pink_noise_prev + bias_instability*np.sqrt(1.0 - np.exp(-2.0*dt[k]/correlation_time)) * np.random.normal(0,1)
        pink_noise_prev = pink_noise[k]
    return pink_noise



def get_brown_noise(random_walk, sample_period, dt, brown_noise_prev=0.0, nlen=1):
    """
    Generate brown noise of desired characteristics.
    It is generated by integrating white noise.

    formula:    BN_k = BN_k-1 + K * sqrt(dt) * wk
    where:
        BN_k is brown noise in instant k
        BN_k-1 is brown noise in the previous instant k
        K is random walk parameter of allan variance analysis
        dt is de sampling period (cte, variable, average or ...)
        wk is normal estandar gaussian distribued noise N(0,1) in instant k

    Arguments
    ----------
    random_walk : float
        Random walk parameter of the simulated sensor.
    sample_period : float
        Sampling period of the simulated sensor.
    dt : np.ndarray
        N array of the sampling periods to compute the integration.
    brown_noise_prev : float, default: 0.0
        Previous brown noise to start integrating from
    nlen: int, default: 1
        Number of samples of brown noise to return.

    Returns
    -------
    _ : np.ndarray or float
        N array with nlen samples of brown noise.

    """
    # if dt.size != nlen:
    #     raise ValueError('The dt size must be the same as nlen, but get dt.size={} and nlen={}'.format(dt.size,nlen))
    # random_walk_disc = random_walk * np.sqrt(sample_period) # x/s*sqrt(Hz) / sqrt(Hz)
    # brown_noise = brown_noise_prev + np.cumsum(random_walk_disc * np.random.normal(0,1,nlen))
    brown_noise = np.zeros(nlen)
    if nlen == 1: dt = np.array([dt])
    for k in range(nlen):
        brown_noise[k] = brown_noise_prev + random_walk*np.sqrt(dt[k])*np.random.normal(0,1)
        brown_noise_prev = brown_noise[k]
    return brown_noise



def saturate(value, min_val, max_val):
    """
    Saturated input data to simulate measurement saturation.

    Arguments
    ----------
    value : np.ndarray or float
        Input data to saturate.
    min_val : float
        Minimum value of the saturated data to output.
    max_val : float
        Maximum value of the saturated data to output.

    Returns
    -------
    _ : np.ndarray or float
        N array with saturated data.

    """
    saturated_value = np.clip(value, min_val, max_val)
    return saturated_value



def digitalize(value, full_range, resolution):
    """
    Digitalize data to simulate quantization of and ADC
    (Analog-to-Digital-Converter).

    Arguments
    ----------
    value : np.ndarray or float
        Input data to digitalize.
    full_range : float
        Amplitude of the output data. Maximum output will be + full_range
        while minimum output will be - full_range.
    resolution : integer
        Number of bits of the converter.

    Returns
    -------
    _ : np.ndarray or float
        N array with digitalized data.

    """
    transfer_function = np.linspace(-full_range, full_range, 2**resolution, endpoint=True)
    bin_indices = np.digitize(value, transfer_function, right=True)
    digital_value = np.take(transfer_function, bin_indices)
    return digital_value